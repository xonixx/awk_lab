#!/bin/sh
exec awk -v "Version=0.9.9" -v "Prog=$0" '
BEGIN {
  Shell = "bash"
  SupportedShells["bash"]
  SupportedShells["sh"]
  SupportedOptions["tracing"]
  SupportedOptions["silent"]
  SupportedOptions["timing"]
  Tmp = isDir("/dev/shm") ? "/dev/shm" : "/tmp"
  split("",Lines)
  split("",Args)
  split("",ArgGoals)
  split("",Options)
  split("",GoalNames)
  split("",GoalsByName)
  split("",Code)
  split("",DefineOverrides)
  DefinesFile=""
  split("",Dependencies)
  split("",DependenciesLineNo)
  split("",DependenciesCnt)
  split("",Doc)
  split("",ReachedIf)
  split("",GlobFiles)
  split("",GlobGoals)
  split("",LibNames)
  split("",Lib)
  split("",UseLibLineNo)
  split("",GoalToLib)
  Mode = "prelude"
  srand()
  prepareArgs()
  MyDirScript = "MYDIR=" quoteArg(getMyDir(ARGV[1])) ";export MYDIR;cd \"$MYDIR\""
  Error=""
}
{
  Lines[NR]=$0
  if ("@options" == $1) handleOptions()
  else if ("@define" == $1) handleDefine()
  else if ("@shell" == $1) handleShell()
  else if ("@goal" == $1) { if ("@glob" == $2 || "@glob" == $3) handleGoalGlob(); else handleGoal() }
  else if ("@doc" == $1) handleDoc()
  else if ("@depends_on" == $1) handleDependsOn()
  else if ("@reached_if" == $1) handleReachedIf()
  else if ("@lib" == $1) handleLib()
  else if ("@use_lib" == $1) handleUseLib()
  else if ($1 ~ /^@/) addError("Unknown directive: " $1)
  else handleCodeLine($0)
}
END { if (!Died) doWork() }
function prepareArgs(   i,arg) {
  for (i = 2; i < ARGC; i++) {
    arg = ARGV[i]
    if (substr(arg,1,1) == "-") {
      if (arg == "-f" || arg == "--file") {
        delete ARGV[i]
        ARGV[1] = ARGV[++i]
      } else if (arg == "-D" || arg == "--define") {
        delete ARGV[i]
        handleOptionDefineOverride(ARGV[++i])
      } else
        Args[arg]
    } else
      arrPush(ArgGoals, arg)
    delete ARGV[i]
  }
  if ("-h" in Args || "--help" in Args) {
    print "makesure ver. " Version
    print "Usage: makesure [options...] [-f buildfile] [goals...]"
    print " -f,--file buildfile"
    print "                 set buildfile to use (default Makesurefile)"
    print " -l,--list       list all available non-@private goals"
    print " -la,--list-all  list all available goals"
    print " -d,--resolved   list resolved dependencies to reach given goals"
    print " -D \"var=val\",--define \"var=val\""
    print "                 override @define values"
    print " -s,--silent     silent mode - only output what goals output"
    print " -t,--timing     display execution times for goals and total"
    print " -x,--tracing    enable tracing in bash/sh via `set -x`"
    print " -v,--version    print version and exit"
    print " -h,--help       print help and exit"
    print " -U,--selfupdate update makesure to latest version"
    realExit(0)
  } else if ("-v" in Args || "--version" in Args) {
    print Version
    realExit(0)
  } else if ("-U" in Args || "--selfupdate" in Args) {
    selfUpdate()
    realExit(0)
  }
  if (!isFile(ARGV[1])) {
    if (isFile(ARGV[1] "/Makesurefile"))
      ARGV[1] = ARGV[1] "/Makesurefile"
    else
      die("makesure file not found: " ARGV[1])
  }
  if ("-s" in Args || "--silent" in Args)
    Options["silent"]
  if ("-x" in Args || "--tracing" in Args)
    Options["tracing"]
  if ("-t" in Args || "--timing" in Args)
    Options["timing"]
}
function splitKV(arg, kv,   n) {
  n = index(arg, "=")
  kv[0] = trim(substr(arg,1,n-1))
  kv[1] = trim(substr(arg,n+1))
}
function handleOptionDefineOverride(arg,   kv) {
  splitKV(arg, kv)
  handleDefineLine(kv[0] "=" quoteArg(kv[1]))
  DefineOverrides[kv[0]]
}
function handleOptions() {
  checkPreludeOnly()
  for (i=2; i<=NF; i++) {
    if (!($i in SupportedOptions))
      addError("Option '\''" $i "'\'' is not supported")
    Options[$i]
  }
}
function handleDefine(   line,kv) {
  checkPreludeOnly()
  $1 = ""
  handleDefineLine($0)
}
function handleDefineLine(line,   kv,l) {
  if (!DefinesFile)
    DefinesFile = executeGetLine("mktemp " Tmp "/makesure.XXXXXXXXXX")
  splitKV(line, kv)
  if (!(kv[0] in DefineOverrides)) {
    handleCodeLine(l = line "; export " kv[0])
    handleCodeLine("echo " quoteArg(l) " >> " DefinesFile)
  }
}
function handleShell() {
  checkPreludeOnly()
  Shell = trim($2)
  if (!(Shell in SupportedShells))
    addError("Shell '\''" Shell "'\'' is not supported")
}
function adjustOptions() {
  if ("silent" in Options)
    delete Options["timing"]
}
function started(mode) {
  if (isPrelude()) adjustOptions()
  Mode = mode
}
function handleLib() {
  started("lib")
  libName = trim($2)
  if (libName in Lib) {
    addError("Lib '\''" libName "'\'' is already defined")
  }
  arrPush(LibNames, libName)
  Lib[libName]
}
function handleUseLib(   goalName) {
  checkGoalOnly()
  if ("goal" == Mode)
    registerUseLib(currentGoalName())
  else {
    for (i=0; i in GlobGoals; i++){
      registerUseLib(GlobGoals[i])
    }
  }
}
function registerUseLib(goalName) {
  if (goalName in GoalToLib)
    addError("You can only use one @lib in a @goal")
  GoalToLib[goalName] = $2
  UseLibLineNo[goalName] = NR
}
function handleGoal(   priv) {
  started("goal")
  priv = parseGoalLine()
  registerGoal($0, priv)
}
function registerGoal(goalName, priv) {
  goalName = trim(goalName)
  if (length(goalName) == 0)
    addError("Goal must have a name")
  if (goalName in GoalsByName)
    addError("Goal '\''" goalName "'\'' is already defined")
  arrPush(GoalNames, goalName)
  GoalsByName[goalName] = priv
}
function calcGlob(goalName, pattern,   script, file) {
  split("",GlobGoals)
  split("",GlobFiles)
  script = MyDirScript ";for f in ./" pattern ";do test -e \"$f\" && echo \"$f\";done"
  while ((script | getline file)>0) {
    file = substr(file, 3)
    arrPush(GlobFiles,file)
    arrPush(GlobGoals,(goalName ? goalName "@" : "") file)
  }
  close(script)
}
function parseGoalLine(   priv) {
  if ($NF == "@private") {
    priv=1
    NF--
  }
  $1 = ""
  return priv
}
function handleGoalGlob(   goalName,priv,i) {
  started("goal_glob")
  priv = parseGoalLine()
  goalName = $2; $2 = ""
  if ("@glob" == goalName) {
    goalName = ""
  } else $3 = ""
  calcGlob(goalName, trim($0))
  for (i=0; i in GlobGoals; i++){
    registerGoal(GlobGoals[i], priv)
  }
}
function handleDoc(   i) {
  checkGoalOnly()
  if ("goal" == Mode)
    registerDoc(currentGoalName())
  else {
    for (i=0; i in GlobGoals; i++){
      registerDoc(GlobGoals[i])
    }
  }
}
function registerDoc(goalName) {
  if (goalName in Doc)
    addError("Multiple " $1 " not allowed for a goal")
  $1 = ""
  Doc[goalName] = trim($0)
}
function handleDependsOn(   i) {
  checkGoalOnly()
  if ("goal" == Mode)
    registerDependsOn(currentGoalName())
  else {
    for (i=0; i in GlobGoals; i++){
      registerDependsOn(GlobGoals[i])
    }
  }
}
function registerDependsOn(goalName,   i,x) {
  for (i=2; i<=NF; i++) {
    Dependencies[x = goalName SUBSEP DependenciesCnt[goalName]++] = $i
    DependenciesLineNo[x] = NR
  }
}
function handleReachedIf(   i) {
  checkGoalOnly()
  if ("goal" == Mode)
    registerReachedIf(currentGoalName())
  else {
    for (i=0; i in GlobGoals; i++){
      registerReachedIf(GlobGoals[i], makeGlobVarsCode(i))
    }
  }
}
function makeGlobVarsCode(i) {
  return "ITEM=" quoteArg(GlobFiles[i]) ";INDEX=" i ";TOTAL=" arrLen(GlobGoals) ";"
}
function registerReachedIf(goalName, preScript) {
  if (goalName in ReachedIf)
    addError("Multiple " $1 " not allowed for a goal")
  $1 = ""
  ReachedIf[goalName] = preScript trim($0)
}
function checkBeforeRun(   i,dep,depCnt) {
  for (goalName in GoalsByName) {
    depCnt = DependenciesCnt[goalName]
    for (i=0; i < depCnt; i++) {
      dep = Dependencies[goalName, i]
      if (!(dep in GoalsByName))
        addError("Goal '\''" goalName "'\'' has unknown dependency '\''" dep "'\''", DependenciesLineNo[goalName, i])
    }
    if (goalName in GoalToLib) {
      if (!(GoalToLib[goalName] in Lib))
        addError("Goal '\''" goalName "'\'' uses unknown lib '\''" GoalToLib[goalName] "'\''", UseLibLineNo[goalName])
    }
  }
}
function doWork(\
  i,j,goalName,depCnt,dep,reachedIf,reachedGoals,emptyGoals,definesLine,
body,goalBody,goalBodies,resolvedGoals,exitCode, t0,t1,t2, goalTimed, list) {
  started("end")
  checkBeforeRun()
  if (Error)
    die(Error)
  list="-l" in Args || "--list" in Args
  if (list || "-la" in Args || "--list-all" in Args) {
    print "Available goals:"
    for (i = 0; i in GoalNames; i++) {
      goalName = GoalNames[i]
      if (list && GoalsByName[goalName])
        continue
      printf "  "
      if (goalName in Doc)
        printf "%s - %s\n", goalName, Doc[goalName]
      else
        print goalName
    }
  } else {
    if ("timing" in Options)
      t0 = currentTimeMillis()
    if (length(body = trim(Code[""])) > 0) {
      goalBody[0] = MyDirScript
      if ("tracing" in Options)
        addLine(goalBody, "set -x")
      addLine(goalBody, body)
      exitCode = shellExec(goalBody[0])
      if (exitCode != 0) {
        print "  prelude failed"
        realExit(exitCode)
      }
    }
    addLine(definesLine, MyDirScript)
    if (DefinesFile)
      addLine(definesLine, ". " DefinesFile)
    for (i = 0; i in GoalNames; i++) {
      goalName = GoalNames[i]
      body = trim(Code[goalName])
      reachedIf = ReachedIf[goalName]
      reachedGoals[goalName] = reachedIf ? checkConditionReached(definesLine[0], reachedIf) : 0
      emptyGoals[goalName] = length(body) == 0
      depCnt = DependenciesCnt[goalName]
      for (j=0; j < depCnt; j++) {
        dep = Dependencies[goalName, j]
        if (!reachedGoals[goalName]) {
          topologicalSortAddConnection(goalName, dep)
        } else {
        }
      }
      goalBody[0] = ""
      if (!("silent" in Options)) {
        addStr(goalBody, "echo \"  goal '\''" goalName "'\'' ")
        if (reachedGoals[goalName])
          addStr(goalBody, "[already satisfied].")
        else if (emptyGoals[goalName])
          addStr(goalBody, "[empty].")
        else
          addStr(goalBody, "...")
        addStr(goalBody, "\"")
      }
      if (reachedGoals[goalName])
        addLine(goalBody, "exit 0")
      addLine(goalBody, definesLine[0])
      if (goalName in GoalToLib)
        addLine(goalBody, Lib[GoalToLib[goalName]])
      if ("tracing" in Options)
        addLine(goalBody, "set -x")
      addLine(goalBody, body)
      goalBodies[goalName] = goalBody[0]
    }
    resolveGoalsToRun(resolvedGoals)
    if ("-d" in Args || "--resolved" in Args) {
      printf("Resolved goals to reach for '\''%s'\'':\n", join(ArgGoals, 0, arrLen(ArgGoals), " "))
      for (i = 0; i in resolvedGoals; i++) {
        print "  " resolvedGoals[i]
      }
    } else {
      for (i = 0; i in resolvedGoals; i++) {
        goalName = resolvedGoals[i]
        goalTimed = "timing" in Options && !reachedGoals[goalName] && !emptyGoals[goalName]
        if (goalTimed)
          t1 = t2 ? t2 : currentTimeMillis()
        exitCode = shellExec(goalBodies[goalName])
        if (exitCode != 0)
          print "  goal '\''" goalName "'\'' failed"
        if (goalTimed) {
          t2 = currentTimeMillis()
          print "  goal '\''" goalName "'\'' took " renderDuration(t2 - t1)
        }
        if (exitCode != 0)
          break
      }
      if ("timing" in Options)
        print "  total time " renderDuration((t2 ? t2 : currentTimeMillis()) - t0)
      if (exitCode != 0)
        realExit(exitCode)
    }
    realExit(0)
  }
}
function resolveGoalsToRun(result,   i, goalName, loop) {
  if (arrLen(ArgGoals) == 0)
    arrPush(ArgGoals, "default")
  for (i = 0; i in ArgGoals; i++) {
    goalName = ArgGoals[i]
    if (!(goalName in GoalsByName)) {
      die("Goal not found: " goalName)
    }
    topologicalSortPerform(goalName, result, loop)
  }
  if (loop[0] == 1) {
    die("There is a loop in goal dependencies via " loop[1] " -> " loop[2])
  }
}
function isPrelude() { return "prelude"==Mode }
function checkPreludeOnly() { if (!isPrelude()) addError("Only use " $1 " in prelude") }
function checkGoalOnly() { if ("goal" != Mode && "goal_glob" != Mode) addError("Only use " $1 " in @goal") }
function currentGoalName() { return isPrelude() ? "" : arrLast(GoalNames) }
function currentLibName() { return arrLast(LibNames) }
function realExit(code,   i) {
  Died = 1
  if (DefinesFile)
    rm(DefinesFile)
  exit code
}
function addError(err, n) { if (!n) n=NR; Error=addL(Error, err ":\n" ARGV[1] ":" n ": " Lines[n]) }
function die(msg,    out) {
  out = "cat 1>&2"
  print msg | out
  close(out)
  realExit(1)
}
function checkConditionReached(definesLine, conditionStr,    script) {
  script = definesLine
  script = script "\n" conditionStr
  return shellExec(script) == 0
}
function shellExec(script,   res) {
  script = Shell " -e -c " quoteArg(script)
  res = system(script)
  return res
}
function getMyDir(makesurefilePath) {
  return executeGetLine("cd \"$(dirname " quoteArg(makesurefilePath) ")\";pwd")
}
function handleCodeLine(line,   goalName) {
  if ("lib" == Mode) {
    name = currentLibName()
    Lib[name] = addL(Lib[name], line)
  } else if ("goal_glob" == Mode) {
    for (i=0; i in GlobGoals; i++){
      if (!Code[goalName = GlobGoals[i]])
        addCodeLine(goalName, makeGlobVarsCode(i))
      addCodeLine(goalName, line)
    }
  } else
    addCodeLine(currentGoalName(), line)
}
function addCodeLine(name, line) {
  Code[name] = addL(Code[name], line)
}
function topologicalSortAddConnection(from, to) {
  Slist[from, ++Scnt[from]] = to
}
function topologicalSortPerform(node, result, loop,   i, s) {
  if (Visited[node] == 2)
    return
  Visited[node] = 1
  for (i = 1; i <= Scnt[node]; i++) {
    if (Visited[s = Slist[node, i]] == 0)
      topologicalSortPerform(s, result, loop)
    else if (Visited[s] == 1) {
      loop[0] = 1
      loop[1] = s
      loop[2] = node
    }
  }
  Visited[node] = 2
  arrPush(result, node)
}
function currentTimeMillis(   script, res) {
  res = executeGetLine("date +%s%3N")
  sub(/%3N/, "000", res)
  return res + 0
}
function selfUpdate(   url, tmp, err, newVer) {
  url = "https://raw.githubusercontent.com/xonixx/makesure/main/makesure_stable?token=" rand()
  tmp = executeGetLine("mktemp /tmp/makesure_new.XXXXXXXXXX")
  err = dl(url, tmp)
  if (!err && !ok("chmod +x " tmp)) err = "can'\''t chmod +x " tmp
  if (!err) {
    newVer = executeGetLine(tmp " -v")
    if (Version != newVer) {
      if (!ok("cp " tmp " " quoteArg(Prog)))
        err = "can'\''t overwrite " Prog
      else print "updated " Version " -> " newVer
    } else print "you have latest version " Version " installed"
  }
  rm(tmp)
  if (err) die(err)
}
function renderDuration(deltaMillis,\
  deltaSec,deltaMin,deltaHr,deltaDay,dayS,hrS,minS,secS,secSI,res) {
  deltaSec = deltaMillis / 1000
  deltaMin = 0
  deltaHr = 0
  deltaDay = 0
  if (deltaSec >= 60) {
    deltaMin = int(deltaSec / 60)
    deltaSec = deltaSec - deltaMin * 60
  }
  if (deltaMin >= 60) {
    deltaHr = int(deltaMin / 60)
    deltaMin = deltaMin - deltaHr * 60
  }
  if (deltaHr >= 24) {
    deltaDay = int(deltaHr / 24)
    deltaHr = deltaHr - deltaDay * 24
  }
  dayS = deltaDay > 0 ? deltaDay " d" : ""
  hrS = deltaHr > 0 ? deltaHr " h" : ""
  minS = deltaMin > 0 ? deltaMin " m" : ""
  secS = deltaSec > 0 ? deltaSec " s" : ""
  secSI = deltaSec > 0 ? int(deltaSec) " s" : ""
  if (dayS != "")
    res = dayS " " (hrS == "" ? "0 h" : hrS)
  else if (deltaHr > 0)
    res = hrS " " (minS == "" ? "0 m" : minS)
  else if (deltaMin > 0)
    res = minS " " (secSI == "" ? "0 s" : secSI)
  else
    res = deltaSec > 0 ? secS : "0 s"
  return res
}
function executeGetLine(script,   res) {
  script | getline res
  close(script)
  return res
}
function dl(url, dest,    verbose) {
  verbose = "VERBOSE" in ENVIRON
  if (commandExists("wget")) {
    if (!ok("wget " (verbose ? "" : "-q") " " quoteArg(url) " -O" quoteArg(dest)))
      return "error with wget"
  } else if (commandExists("curl")) {
    if (!ok("curl " (verbose ? "" : "-s") " " quoteArg(url) " -o " quoteArg(dest)))
      return "error with curl"
  } else return "wget/curl no found"
}
function join(arr, startIncl, endExcl, sep,   result, i) {
  result = arr[startIncl]
  for (i = startIncl + 1; i < endExcl; i++)
    result = result sep arr[i]
  return result
}
function addStr(target, str) { target[0] = target[0] str }
function addLine(target, line) { target[0] = addL(target[0], line) }
function addL(s, l) { return s ? s "\n" l : l }
function arrPush(arr, elt) { arr[arr[-7]++] = elt }
function arrLen(arr) { return 0 + arr[-7] }
function arrLast(arr) { return arr[arrLen(arr)-1] }
function commandExists(cmd) { return ok("command -v " cmd " >/dev/null") }
function ok(cmd) { return system(cmd) == 0 }
function isFile(path) { return ok("test -f " quoteArg(path)) }
function isDir(path) { return ok("test -d " quoteArg(path)) }
function rm(f) { system("rm " quoteArg(f)) }
function quoteArg(a) { gsub("'\''", "'\''\\'\'''\''", a); return "'\''" a "'\''" }
function trim(s) { sub(/^[ \t\r\n]+/, "", s); sub(/[ \t\r\n]+$/, "", s); return s }
' Makesurefile "$@"
